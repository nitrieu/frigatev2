#define wiresize 128
#parties 2
#define Nr 10
#define Nb 4
#define Nk 4

typedef uint_t 8 uint8_t
typedef uint_t wiresize uint128_t
typedef uint_t 16*(Nr+1) uintKE_t

#input 1 uint128_t
#input 2 uint128_t
#output 1 uint128_t

function uint8_t sbox(uint8_t idx)
{
return idx; /*use Yale sbox here*/
}


function uint8_t[11][16] KeyExpansion(uint128_t key)
{
uint8_t RoundKey[11][16];
uint8_t temp[4];
uint8_t k;

uint8_t Rcon[11]={141,1,2,4,8,16,32,64,128, 27,54 };


/* The first round key is the key itself.*/
	
for(uint8_t j=0; j < 15; j++)
	     { 
		   RoundKey[0][j]=key{j*8:8};
	    }


/*  All other round keys are found from the previous round keys. */
for(uint8_t i=1; i < 11; i++)
  {    
	/* 1st 4 bytes: divided by 4: 16 17 18 19 */
	   for(uint8_t j=0; j < 4; j++)
	     { 
		   temp[j]=RoundKey[i-1][12+j];
	    }

	/* Function RotWord() */
        k = temp[0];
        temp[0] = temp[1];
        temp[1] = temp[2];
        temp[2] = temp[3];
        temp[3] = k;
  
	/* Function Subword() */
        temp[0] = sbox(temp[0]);
        temp[1] = sbox(temp[1]);
        temp[2] = sbox(temp[2]);
        temp[3] = sbox(temp[3]);

         temp[0] =  temp[0] ^ Rcon[i];

 	for(uint8_t j=0; j < 4; j++)
	     { 
		   RoundKey[i][j]=RoundKey[i-1][j]^temp[j];
	    }	

/* other bytes 20 ---31*/

 	for(uint8_t j=1; j < 4; j++)
	     { 
		RoundKey[i][4*j]=RoundKey[i-1][4*j]^RoundKey[i][4*(j-1)];
		RoundKey[i][4*j+1]=RoundKey[i-1][4*j+1]^RoundKey[i][4*(j-1)+1];
		RoundKey[i][4*j+2]=RoundKey[i-1][4*j+2]^RoundKey[i][4*(j-1)+2];
		RoundKey[i][4*j+3]=RoundKey[i-1][4*j+3]^RoundKey[i][4*(j-1)+3];
	}
 }

return RoundKey;
}



function uint8_t[16] SubBytes(uint8_t buf[16])
{
    for(uint8_t i=0;i<16;i++)
   {
       buf[i] = sbox(buf[i]);
   }
   return buf;
} 


function uint8_t[16] ShiftRows(uint8_t buf[16])
{
    
	uint8_t i;
/*shift 2nd row*/
i=buf[1];
buf[1]=buf[5];
buf[5]=buf[9];
buf[9]=buf[13];
buf[13]=i;

/*shift 3rd row*/
i=buf[2];
buf[2]=buf[10];
buf[10]=i;

i=buf[6];
buf[6]=buf[14];
buf[14]=i;

/*shift 4th row*/
i=buf[3];
buf[3]=buf[15];
buf[15]=buf[11];
buf[11]=buf[7];
buf[7]=i;

return buf;
} 



function uint8_t[16] MixColumns(uint8_t buf[16])
{
    for(uint8_t i=0; i < 4; i++) {
        uint8_t a[4];
        uint8_t b[4];
        uint8_t h;
        for(uint8_t c=0;c<4;c++) {
                a[c] = buf[4*i+c];
                h = (buf[4*i+c] >> 7)&1; 
                b[c] = buf[4*i+c] << 1; 
                b[c] = b[c]^ (27 * h); /* Rijndael's Galois field */
        }
        buf[4*i] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
        buf[4*i+1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
        buf[4*i+2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
        buf[4*i+3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */
    }

return buf;
} 




function uint8_t[16] AddRoundKey(uint8_t buf[16], uint8_t key[16])
{
uint8_t res[16];
for(uint8_t i=0; i < 16; i++) {
res[i]=buf[i]^key[i];
}
return res;
} 

function uint8_t[16] AddRoundKey_128( uint128_t buf, uint8_t key[16])
{
uint8_t res[16];
   for(uint8_t i=0; i < 4; i++) {
res[i]=buf{i*8:8}^key[i];
}
return res;

} 


function uint128_t getOutput(uint8_t key[16])
{

 uint128_t rs;
	for(uint8_t c=0;c<16;c++) {
	rs{c*8:8}=key[c];
	}
   return rs;
} 


function void main()
{

	uint8_t buff[16];
	uint8_t keyEx[11][16];

	keyEx=KeyExpansion(input2);
	buff=AddRoundKey_128(input1,keyEx[0]);

        for(uint8_t i=1;i<Nr;i++)
	{
		buff=SubBytes(buff);
		buff=ShiftRows(buff);
		buff=MixColumns(buff);
                buff=AddRoundKey(buff,keyEx[i]);	
	}		buff=SubBytes(buff);
		buff=ShiftRows(buff);
 
               buff=AddRoundKey(buff,keyEx[Nr]);
output1=getOutput(buff);


}
